{"version":3,"sources":["../../src/index.ts","../../../src/yupSchemas/user.ts","serviceWorker.ts","apollo.ts","../../../../src/modules/RegisterController/index.tsx","modules/shared/InputField.tsx","modules/register/ui/RegisterView.tsx","modules/register/RegisterConnector.tsx","routes/index.tsx","index.tsx"],"names":["Boolean","window","location","hostname","match","client","ApolloClient","link","HttpLink","uri","process","credentials","cache","InMemoryCache","FormItem","Form","Item","InputField","field","form","touched","errors","props","errorMsg","name","help","validateStatus","undefined","AntForm","C","style","display","width","margin","prefix","UserOutlined","className","placeholder","component","type","LockOutlined","href","htmlType","PureComponent","RegisterView","withFormik","validationSchema","validUserSchema","mapPropsToValues","email","password","handleSubmit","values","a","setErrors","submit","RegisterConnector","RegisterController","Routes","exact","path","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"0dAAA,a,2OCAA,aAKa,qBAAqB,sCACrB,wBAAwB,yCACxB,gBAAgB,8BAEhB,6BAA6B,EACvC,SACA,IAAI,EAAG,yBACP,IAAI,KACJ,WAEU,kBAAkB,EAAI,SAAS,MAAM,CAC9C,MAAK,EACJ,SACA,IAAI,EAAG,sBACP,IAAI,KACJ,MAAM,iBACN,WACH,SAAU,gC,mGCVQA,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2D,yCCdOC,EAAS,IAAIC,IAAa,CACrCC,KAAM,IAAIC,IAAS,CACjBC,IAAKC,iDACLC,YAAa,YAEfC,MAAO,IAAIC,M,u0DCSb,cAAE,SAAF,IAAI,IAAJ,0C,OAGM,EAAJ,OAAS,SAAO,GAAiC,qC,wDAE9B,OADjB,QAAQ,IAAI,GACK,GAAM,KAAK,MAAM,OAAO,CACvC,UAAW,K,OAGb,OAJM,EAAW,SAGjB,QAAQ,IAAI,aAAc,GAC1B,GAAO,c,EAMT,OAfc,OAYZ,EAAF,4BACM,OAAG,KAAK,MAAM,SAAS,CAAE,OAAQ,KAAK,UAE9C,EAfA,CAAgB,iBAiBV,EAAmB,IAAG,uVASf,EAAqB,YAIhC,EAJgC,CAId,G,kGC5CdC,EAAWC,IAAKC,KAKTC,EAA8C,SAAC,GAIrD,IAHLC,EAGI,EAHJA,MAGI,IAFJC,KAAQC,EAEJ,EAFIA,QAASC,EAEb,EAFaA,OACdC,EACC,gCACEC,EAAWH,EAAQF,EAAMM,OAASH,EAAOH,EAAMM,MAErD,OACE,gBAACV,EAAD,CAAUW,KAAMF,EAAUG,eAAgBH,EAAW,aAAUI,GAC7D,gBAAC,IAAD,iBACMT,EACAI,MCbNR,EAAWc,IAAQZ,KAmBZa,EAAb,uKAEI,OACE,kBAAC,IAAD,CAIEC,MAAO,CAAEC,QAAS,SAElB,yBAAKD,MAAO,CAAEE,MAAO,IAAKC,OAAQ,SAChC,kBAAC,IAAD,CAGET,KAAK,QACLU,OAAQ,kBAACC,EAAA,EAAD,CAAcC,UAAU,wBAChCC,YAAY,QACZC,UAAWrB,IAEb,kBAAC,IAAD,CAGEO,KAAK,WACLe,KAAK,WACLL,OAAQ,kBAACM,EAAA,EAAD,CAAcJ,UAAU,wBAChCC,YAAY,WACZC,UAAWrB,IAEb,kBAAC,EAAD,KACE,uBAAGmB,UAAU,oBAAoBK,KAAK,KAAtC,oBAIF,kBAAC,EAAD,KACE,kBAAC,IAAD,CACEF,KAAK,UACLG,SAAS,SACTN,UAAU,qBAHZ,aAQF,kBAAC,EAAD,WACK,uBAAGK,KAAK,KAAR,qBA1Cf,GAAuBE,iBA6DVC,EAAeC,YAA8B,CACxDC,iBAAkBC,kBAClBC,iBAAkB,iBAAO,CAAEC,MAAO,GAAIC,SAAU,KAChDC,aAAa,WAAD,4BAAE,WAAOC,EAAP,sBAAAC,EAAA,6DAAiB/B,EAAjB,EAAiBA,MAAOgC,EAAxB,EAAwBA,UAAxB,SACShC,EAAMiC,OAAOH,GADtB,QACN/B,EADM,SAGViC,EAAUjC,GAHA,2CAAF,qDAAC,IAHawB,CASzBhB,GCrFU2B,EAAb,uKAEI,OACE,6BACE,kBAACC,EAAD,MAMG,gBAAGF,EAAH,EAAGA,OAAH,OAAgB,kBAACX,EAAD,CAAcW,OAAQA,YAVjD,GAAuCZ,iBCP1Be,EAAS,kBACpB,gBAAC,IAAD,KACE,gBAAC,IAAD,KAEE,gBAAC,IAAD,CAAOC,OAAO,EAAMC,KAAK,YAAYtB,UAAWkB,O,OCAtDK,IAASC,OACP,kBAAC,IAAD,CAAgBzD,OAAQA,GACtB,kBAAC,EAAD,OAEF0D,SAASC,eAAe,SP+HpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLC,QAAQD,MAAMA,EAAME,c","file":"static/js/main.3d8f4cc4.chunk.js","sourcesContent":["export * from \"./modules/RegisterController\";\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validUserSchema = exports.registerPasswordValidation = exports.emailNotValid = exports.passwordNotLongEnough = exports.emailNotLongEnough = void 0;\nconst yup = require(\"yup\");\nexports.emailNotLongEnough = \"email must be at least 3 characters\";\nexports.passwordNotLongEnough = \"password must be at least 3 characters\";\nexports.emailNotValid = \"email must be a valid email\";\nexports.registerPasswordValidation = yup\n    .string()\n    .min(3, exports.passwordNotLongEnough)\n    .max(255)\n    .required();\nexports.validUserSchema = yup.object().shape({\n    email: yup\n        .string()\n        .min(3, exports.emailNotLongEnough)\n        .max(255)\n        .email(exports.emailNotValid)\n        .required(),\n    password: exports.registerPasswordValidation\n});\n//# sourceMappingURL=user.js.map","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import { ApolloClient } from \"apollo-client\";\nimport { InMemoryCache } from \"apollo-cache-inmemory\";\nimport { HttpLink } from \"apollo-link-http\";\n\nexport const client = new ApolloClient({\n  link: new HttpLink({\n    uri: process.env.REACT_APP_SERVER_URL, // there are 2 env files, for dev and production\n    credentials: \"include\"\n  }),\n  cache: new InMemoryCache()\n});\n","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n    return cooked;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport * as React from \"react\";\nimport { graphql } from \"react-apollo\";\nimport gql from \"graphql-tag\";\n/* ChildMutateProps is used to specify the types of the values\nexpected. First parameter are the Props we have above, then you have\nwhat is expected to come from the mutation and then the variables */\nvar C = /** @class */ (function (_super) {\n    __extends(C, _super);\n    function C() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.submit = function (values) { return __awaiter(_this, void 0, void 0, function () {\n            var response;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        console.log(values);\n                        return [4 /*yield*/, this.props.mutate({\n                                variables: values\n                            })];\n                    case 1:\n                        response = _a.sent();\n                        console.log(\"response: \", response);\n                        return [2 /*return*/, null];\n                }\n            });\n        }); };\n        return _this;\n    }\n    C.prototype.render = function () {\n        return this.props.children({ submit: this.submit });\n    };\n    return C;\n}(React.PureComponent));\nvar registerMutation = gql(templateObject_1 || (templateObject_1 = __makeTemplateObject([\"\\n  mutation RegisterMutation($email: String!, $password: String!) {\\n    register(email: $email, password: $password) {\\n      path\\n      message\\n    }\\n  }\\n\"], [\"\\n  mutation RegisterMutation($email: String!, $password: String!) {\\n    register(email: $email, password: $password) {\\n      path\\n      message\\n    }\\n  }\\n\"])));\nexport var RegisterController = graphql(registerMutation)(C);\nvar templateObject_1;\n//# sourceMappingURL=index.js.map","import * as React from \"react\";\nimport { FieldProps } from \"formik\";\nimport { Form, Input } from \"antd\";\n\nconst FormItem = Form.Item;\n\n/* This component works kinda like a function. It is a template\nfor an input, and we can pass values */\n\nexport const InputField: React.SFC<FieldProps<any> & {}> = ({\n  field, // { name, value, onChange, onBlur }\n  form: { touched, errors }, // also values, setXXXX, handleXXXX, dirty, isValid, status, etc.\n  ...props\n}) => {\n  const errorMsg = touched[field.name] && errors[field.name];\n\n  return (\n    <FormItem help={errorMsg} validateStatus={errorMsg ? \"error\" : undefined}>\n      <Input\n        {...field}\n        {...props} // spreading the field and the props to put all of their things in our template input\n      />\n    </FormItem>\n  );\n};\n\n/* \nI will leave here as reference how an input field was before. It can\nnow be rendered by this template\n\nvalues, handleChange, handleBlur, handleSubmit, touched, errors were coming from the props\n\n<FormItem\n  help={touched.email && errors.email ? errors.email : null}\n  validateStatus={touched.email && errors.email ? \"error\" : undefined}\n>\n  <Input\n    name=\"email\"\n    prefix={<UserOutlined className=\"site-form-item-icon\" />}\n    placeholder=\"Email\"\n    value={values.email}\n    onChange={handleChange}\n    onBlur={handleBlur}\n  />\n</FormItem>\n*/\n","import React, { PureComponent } from \"react\";\nimport { Form as AntForm, Button } from \"antd\"; // name conflict with Formik Form\nimport { UserOutlined, LockOutlined } from \"@ant-design/icons\";\nimport { withFormik, FormikErrors, FormikProps, Field, Form } from \"formik\";\nimport { validUserSchema } from \"@cribswap/common\";\nimport { InputField } from \"../../shared/InputField\";\n\nconst FormItem = AntForm.Item;\n\n/* interfaces are the typescript definitions */\ninterface FormValues {\n  email: string;\n  password: string;\n}\n\ninterface Props {\n  submit: (values: FormValues) => Promise<FormikErrors<FormValues> | null>;\n  /* there's not always gonna be errors, so either it receives formikerrors\nor null */\n}\n\n/* C is wrapped in a high order component withFormik, now we have access\nto some props, which are */\n/* touched is used to know when a field is being interacted with, eg\nnot show error messages before the user interacts. help is to show\nthe error on the field */\nexport class C extends PureComponent<FormikProps<FormValues> & Props> {\n  render() {\n    return (\n      <Form\n        /* using Form from Formik instead of the normal form saves us\n      from having to do a onSubmit={handleSubmit}. Formik does \n      everything. */\n        style={{ display: \"flex\" }}\n      >\n        <div style={{ width: 400, margin: \"auto\" }}>\n          <Field\n            /* using the template InputField component just passing \n            the name and the extra unique things */\n            name=\"email\"\n            prefix={<UserOutlined className=\"site-form-item-icon\" />}\n            placeholder=\"Email\"\n            component={InputField}\n          />\n          <Field\n            /* using the template InputField component just passing \n            the name and the extra unique things */\n            name=\"password\"\n            type=\"password\"\n            prefix={<LockOutlined className=\"site-form-item-icon\" />}\n            placeholder=\"Password\"\n            component={InputField}\n          />\n          <FormItem>\n            <a className=\"login-form-forgot\" href=\"/\">\n              Forgot password\n            </a>\n          </FormItem>\n          <FormItem>\n            <Button\n              type=\"primary\"\n              htmlType=\"submit\"\n              className=\"login-form-button\"\n            >\n              Register\n            </Button>\n          </FormItem>\n          <FormItem>\n            Or <a href=\"/\">login now!</a>\n          </FormItem>\n        </div>\n      </Form>\n    );\n  }\n}\n\n/* mapPropsToValues has access to the props in the parameters of \nthe function. The props that where passed to this view \nand folowing you define the default values of your fields, which we\nleft \"\" (I am assuming you can make one of them default as a prop)\nFormik requires to have the name of the input there!*/\n/* handleSubmit will be called when the form is submited, the values\nare the fields which can be expanded {}. The second parameters is the\nformik bag  */\n/* Formik has a integration with yup in a prop called\nvalidationSchema */\n\nexport const RegisterView = withFormik<Props, FormValues>({\n  validationSchema: validUserSchema,\n  mapPropsToValues: () => ({ email: \"\", password: \"\" }),\n  handleSubmit: async (values, { props, setErrors }) => {\n    const errors = await props.submit(values);\n    if (errors) {\n      setErrors(errors);\n    }\n  }\n})(C);\n","import React, { PureComponent } from \"react\";\nimport { RegisterController } from \"@cribswap/controller\";\n\nimport { RegisterView } from \"./ui/RegisterView\";\n\n/* So, We have a controller that does the calls to the backend.\nThe controllers are in a separate package, which is imported to\nweb and will be imported to the app too. This is for sharing code\nThis file here is the connector, which is meant to connect the\ncontroller and pass it to a View with a function. */\n\nexport class RegisterConnector extends PureComponent {\n  render() {\n    return (\n      <div>\n        <RegisterController\n        /* the children of the register controller is this function\n        which pass submit to the view. In the controller package\n        we are passing the submit function inside an object to the\n        this.props.children. That's why we can get it here */\n        >\n          {({ submit }) => <RegisterView submit={submit} />}\n        </RegisterController>\n      </div>\n    );\n  }\n}\n","import * as React from \"react\";\nimport { BrowserRouter, Route, Switch } from \"react-router-dom\";\nimport { RegisterConnector } from \"../modules/register/RegisterConnector\";\n\nexport const Routes = () => (\n  <BrowserRouter>\n    <Switch>\n      {/* switch doesn't allow to render multiple routes, it renders the first one that matches */}\n      <Route exact={true} path=\"/register\" component={RegisterConnector} />\n    </Switch>\n  </BrowserRouter>\n);\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport { ApolloProvider } from \"react-apollo\";\nimport { client } from \"./apollo\";\nimport { Routes } from \"./routes\";\nimport \"./index.css\";\n\nReactDOM.render(\n  <ApolloProvider client={client}>\n    <Routes />\n  </ApolloProvider>,\n  document.getElementById(\"root\") as HTMLElement\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n\n/* \nI am not running strict mode bc I was getting always a console warning\nindex.js:1 Warning: findDOMNode is deprecated in StrictMode.\nThis is still to be fixed, so until then I am not running in strict\nbc the warning is annoying\n\n\nReactDOM.render(\n  <React.StrictMode>\n    <ApolloProvider\n      client={client}\n      // apolloprovider allows to do graphql requests from anywhere in the app\n    >\n      <Routes />\n    </ApolloProvider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n */\n"],"sourceRoot":""}